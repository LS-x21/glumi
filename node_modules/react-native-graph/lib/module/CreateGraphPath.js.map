{"version":3,"sources":["CreateGraphPath.ts"],"names":["Skia","cartesian2Polar","createSplineFunction","controlPoint","reverse","smoothing","current","previous","next","p","n","lengthX","x","lengthY","y","o","angle","theta","Math","PI","length","radius","cos","sin","getGraphPathRange","points","range","minValueX","min","date","maxValueX","max","minValueY","reduce","prev","curr","value","Number","MAX_SAFE_INTEGER","maxValueY","MIN_SAFE_INTEGER","pixelFactorX","minValue","maxValue","diff","getTime","pixelFactorY","PIXEL_RATIO","createGraphPathBase","horizontalPadding","verticalPadding","canvasHeight","height","canvasWidth","width","shouldFillGradient","path","Path","Make","actualWidth","actualHeight","getGraphPoint","point","firstPoint","moveTo","forEach","i","prevPrev","currentPoint","prevPoint","prevPrevPoint","nextPoint","cps","cpe","splineFunction","drawingFactor","Date","drawingPixels","numberOfDrawingPoints","floor","i2","cubicTo","gradientPath","copy","lastPointX","lineTo","createGraphPath","props","createGraphPathWithGradient"],"mappings":"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","sourcesContent":["import {\n  SkPath,\n  Skia,\n  Vector,\n  cartesian2Polar,\n} from '@shopify/react-native-skia'\nimport type { GraphPoint, GraphRange } from './LineGraphProps'\nimport { createSplineFunction } from './Maths'\n\nexport interface GraphXRange {\n  min: Date\n  max: Date\n}\n\nexport interface GraphYRange {\n  min: number\n  max: number\n}\n\nexport interface GraphPathRange {\n  x: GraphXRange\n  y: GraphYRange\n}\n\ntype GraphPathConfig = {\n  /**\n   * Graph Points to use for the Path. Will be normalized and centered.\n   */\n  points: GraphPoint[]\n  /**\n   * Optional Padding (left, right) for the Graph to correctly round the Path.\n   */\n  horizontalPadding: number\n  /**\n   * Optional Padding (top, bottom) for the Graph to correctly round the Path.\n   */\n  verticalPadding: number\n  /**\n   * Height of the Canvas (Measured with onLayout)\n   */\n  canvasHeight: number\n  /**\n   * Width of the Canvas (Measured with onLayout)\n   */\n  canvasWidth: number\n  /**\n   * Smoothing of the graph path (usually between 0.2 and 0.5)\n   */\n  smoothing?: number\n  /**\n   * Range of the graph's x and y-axis\n   */\n  range: GraphPathRange\n}\n\ntype GraphPathConfigWithGradient = GraphPathConfig & {\n  shouldFillGradient: true\n}\ntype GraphPathConfigWithoutGradient = GraphPathConfig & {\n  shouldFillGradient: false\n}\n\nexport const controlPoint = (\n  reverse: boolean,\n  smoothing: number,\n  current: Vector,\n  previous: Vector,\n  next: Vector\n): Vector => {\n  const p = previous\n  const n = next\n  // Properties of the opposed-line\n  const lengthX = n.x - p.x\n  const lengthY = n.y - p.y\n\n  const o = cartesian2Polar({ x: lengthX, y: lengthY })\n  // If is end-control-point, add PI to the angle to go backward\n  const angle = o.theta + (reverse ? Math.PI : 0)\n  const length = o.radius * smoothing\n  // The control point position is relative to the current point\n  const x = current.x + Math.cos(angle) * length\n  const y = current.y + Math.sin(angle) * length\n  return { x, y }\n}\n\nexport function getGraphPathRange(\n  points: GraphPoint[],\n  range?: GraphRange\n): GraphPathRange {\n  const minValueX = range?.x?.min ?? points[0]!.date\n  const maxValueX = range?.x?.max ?? points[points.length - 1]!.date\n\n  const minValueY =\n    range?.y?.min ??\n    points.reduce(\n      (prev, curr) => (curr.value < prev ? curr.value : prev),\n      Number.MAX_SAFE_INTEGER\n    )\n  const maxValueY =\n    range?.y?.max ??\n    points.reduce(\n      (prev, curr) => (curr.value > prev ? curr.value : prev),\n      Number.MIN_SAFE_INTEGER\n    )\n\n  return {\n    x: { min: minValueX, max: maxValueX },\n    y: { min: minValueY, max: maxValueY },\n  }\n}\n\nexport const pixelFactorX = (\n  date: Date,\n  minValue: Date,\n  maxValue: Date\n): number => {\n  const diff = maxValue.getTime() - minValue.getTime()\n  const x = date.getTime()\n\n  if (x < minValue.getTime() || x > maxValue.getTime()) return 0\n  return (x - minValue.getTime()) / diff\n}\n\nexport const pixelFactorY = (\n  value: number,\n  minValue: number,\n  maxValue: number\n): number => {\n  const diff = maxValue - minValue\n  const y = value\n\n  if (y < minValue || y > maxValue) return 0\n  return (y - minValue) / diff\n}\n\n// A Graph Point will be drawn every second \"pixel\"\nconst PIXEL_RATIO = 2\n\ntype GraphPathWithGradient = { path: SkPath; gradientPath: SkPath }\n\nfunction createGraphPathBase(\n  props: GraphPathConfigWithGradient\n): GraphPathWithGradient\nfunction createGraphPathBase(props: GraphPathConfigWithoutGradient): SkPath\n\nfunction createGraphPathBase({\n  points,\n  smoothing = 0.2,\n  range,\n  horizontalPadding,\n  verticalPadding,\n  canvasHeight: height,\n  canvasWidth: width,\n  shouldFillGradient,\n}: GraphPathConfigWithGradient | GraphPathConfigWithoutGradient):\n  | SkPath\n  | GraphPathWithGradient {\n  const path = Skia.Path.Make()\n\n  const actualWidth = width - 2 * horizontalPadding\n  const actualHeight = height - 2 * verticalPadding\n\n  const getGraphPoint = (point: GraphPoint): Vector => {\n    const x =\n      actualWidth * pixelFactorX(point.date, range.x.min, range.x.max) +\n      horizontalPadding\n    const y =\n      actualHeight -\n      actualHeight * pixelFactorY(point.value, range.y.min, range.y.max) +\n      verticalPadding\n\n    return { x: x, y: y }\n  }\n\n  if (points[0] == null) return path\n\n  const firstPoint = getGraphPoint(points[0])\n  path.moveTo(firstPoint.x, firstPoint.y)\n\n  points.forEach((point, i) => {\n    if (i === 0) {\n      return\n    }\n\n    if (point.date < range.x.min || point.date > range.x.max) return\n\n    const prev = points[i - 1]\n\n    if (prev == null) return\n    const prevPrev = points[i - 2] ?? prev\n    const next = points[i + 1] ?? point\n\n    const currentPoint = getGraphPoint(point)\n    const prevPoint = getGraphPoint(prev)\n    const prevPrevPoint = getGraphPoint(prevPrev)\n    const nextPoint = getGraphPoint(next)\n\n    const cps = controlPoint(\n      false,\n      smoothing,\n      prevPoint,\n      prevPrevPoint,\n      currentPoint\n    )\n    const cpe = controlPoint(\n      true,\n      smoothing,\n      currentPoint,\n      prevPoint,\n      nextPoint\n    )\n\n    const splineFunction = createSplineFunction(\n      prevPoint,\n      cps,\n      cpe,\n      currentPoint\n    )\n\n    // Calculates how many points between two points must be\n    // calculated and drawn onto the canvas\n    const drawingFactor = pixelFactorX(\n      new Date(point.date.getTime() - prev.date.getTime()),\n      range.x.min,\n      range.x.max\n    )\n    const drawingPixels = actualWidth * drawingFactor + horizontalPadding\n    const numberOfDrawingPoints = Math.floor(drawingPixels / PIXEL_RATIO)\n\n    for (let i2 = 0; i2 <= numberOfDrawingPoints; i2++) {\n      const p = splineFunction(i2 / numberOfDrawingPoints)\n\n      if (p == null) return\n      path.cubicTo(p.x, p.y, p.x, p.y, p.x, p.y)\n    }\n  })\n\n  if (!shouldFillGradient) return path\n\n  const gradientPath = path.copy()\n\n  const lastPointX = pixelFactorX(\n    points[points.length - 1]!.date,\n    range.x.min,\n    range.x.max\n  )\n\n  gradientPath.lineTo(\n    actualWidth * lastPointX + horizontalPadding,\n    height + verticalPadding\n  )\n  gradientPath.lineTo(0 + horizontalPadding, height + verticalPadding)\n\n  return { path: path, gradientPath: gradientPath }\n}\n\nexport function createGraphPath(props: GraphPathConfig): SkPath {\n  return createGraphPathBase({ ...props, shouldFillGradient: false })\n}\n\nexport function createGraphPathWithGradient(\n  props: GraphPathConfig\n): GraphPathWithGradient {\n  return createGraphPathBase({\n    ...props,\n    shouldFillGradient: true,\n  })\n}\n"]}