import { Skia, cartesian2Polar } from '@shopify/react-native-skia';
import { createSplineFunction } from './Maths';
export const controlPoint = (reverse, smoothing, current, previous, next) => {
  const p = previous;
  const n = next; // Properties of the opposed-line

  const lengthX = n.x - p.x;
  const lengthY = n.y - p.y;
  const o = cartesian2Polar({
    x: lengthX,
    y: lengthY
  }); // If is end-control-point, add PI to the angle to go backward

  const angle = o.theta + (reverse ? Math.PI : 0);
  const length = o.radius * smoothing; // The control point position is relative to the current point

  const x = current.x + Math.cos(angle) * length;
  const y = current.y + Math.sin(angle) * length;
  return {
    x,
    y
  };
};
export function getGraphPathRange(points, range) {
  var _range$x$min, _range$x, _range$x$max, _range$x2, _range$y$min, _range$y, _range$y$max, _range$y2;

  const minValueX = (_range$x$min = range === null || range === void 0 ? void 0 : (_range$x = range.x) === null || _range$x === void 0 ? void 0 : _range$x.min) !== null && _range$x$min !== void 0 ? _range$x$min : points[0].date;
  const maxValueX = (_range$x$max = range === null || range === void 0 ? void 0 : (_range$x2 = range.x) === null || _range$x2 === void 0 ? void 0 : _range$x2.max) !== null && _range$x$max !== void 0 ? _range$x$max : points[points.length - 1].date;
  const minValueY = (_range$y$min = range === null || range === void 0 ? void 0 : (_range$y = range.y) === null || _range$y === void 0 ? void 0 : _range$y.min) !== null && _range$y$min !== void 0 ? _range$y$min : points.reduce((prev, curr) => curr.value < prev ? curr.value : prev, Number.MAX_SAFE_INTEGER);
  const maxValueY = (_range$y$max = range === null || range === void 0 ? void 0 : (_range$y2 = range.y) === null || _range$y2 === void 0 ? void 0 : _range$y2.max) !== null && _range$y$max !== void 0 ? _range$y$max : points.reduce((prev, curr) => curr.value > prev ? curr.value : prev, Number.MIN_SAFE_INTEGER);
  return {
    x: {
      min: minValueX,
      max: maxValueX
    },
    y: {
      min: minValueY,
      max: maxValueY
    }
  };
}
export const pixelFactorX = (date, minValue, maxValue) => {
  const diff = maxValue.getTime() - minValue.getTime();
  const x = date.getTime();
  if (x < minValue.getTime() || x > maxValue.getTime()) return 0;
  return (x - minValue.getTime()) / diff;
};
export const pixelFactorY = (value, minValue, maxValue) => {
  const diff = maxValue - minValue;
  const y = value;
  if (y < minValue || y > maxValue) return 0;
  return (y - minValue) / diff;
}; // A Graph Point will be drawn every second "pixel"

const PIXEL_RATIO = 2;

function createGraphPathBase(_ref) {
  let {
    points,
    smoothing = 0.2,
    range,
    horizontalPadding,
    verticalPadding,
    canvasHeight: height,
    canvasWidth: width,
    shouldFillGradient
  } = _ref;
  const path = Skia.Path.Make();
  const actualWidth = width - 2 * horizontalPadding;
  const actualHeight = height - 2 * verticalPadding;

  const getGraphPoint = point => {
    const x = actualWidth * pixelFactorX(point.date, range.x.min, range.x.max) + horizontalPadding;
    const y = actualHeight - actualHeight * pixelFactorY(point.value, range.y.min, range.y.max) + verticalPadding;
    return {
      x: x,
      y: y
    };
  };

  if (points[0] == null) return path;
  const firstPoint = getGraphPoint(points[0]);
  path.moveTo(firstPoint.x, firstPoint.y);
  points.forEach((point, i) => {
    var _points, _points2;

    if (i === 0) {
      return;
    }

    if (point.date < range.x.min || point.date > range.x.max) return;
    const prev = points[i - 1];
    if (prev == null) return;
    const prevPrev = (_points = points[i - 2]) !== null && _points !== void 0 ? _points : prev;
    const next = (_points2 = points[i + 1]) !== null && _points2 !== void 0 ? _points2 : point;
    const currentPoint = getGraphPoint(point);
    const prevPoint = getGraphPoint(prev);
    const prevPrevPoint = getGraphPoint(prevPrev);
    const nextPoint = getGraphPoint(next);
    const cps = controlPoint(false, smoothing, prevPoint, prevPrevPoint, currentPoint);
    const cpe = controlPoint(true, smoothing, currentPoint, prevPoint, nextPoint);
    const splineFunction = createSplineFunction(prevPoint, cps, cpe, currentPoint); // Calculates how many points between two points must be
    // calculated and drawn onto the canvas

    const drawingFactor = pixelFactorX(new Date(point.date.getTime() - prev.date.getTime()), range.x.min, range.x.max);
    const drawingPixels = actualWidth * drawingFactor + horizontalPadding;
    const numberOfDrawingPoints = Math.floor(drawingPixels / PIXEL_RATIO);

    for (let i2 = 0; i2 <= numberOfDrawingPoints; i2++) {
      const p = splineFunction(i2 / numberOfDrawingPoints);
      if (p == null) return;
      path.cubicTo(p.x, p.y, p.x, p.y, p.x, p.y);
    }
  });
  if (!shouldFillGradient) return path;
  const gradientPath = path.copy();
  const lastPointX = pixelFactorX(points[points.length - 1].date, range.x.min, range.x.max);
  gradientPath.lineTo(actualWidth * lastPointX + horizontalPadding, height + verticalPadding);
  gradientPath.lineTo(0 + horizontalPadding, height + verticalPadding);
  return {
    path: path,
    gradientPath: gradientPath
  };
}

export function createGraphPath(props) {
  return createGraphPathBase({ ...props,
    shouldFillGradient: false
  });
}
export function createGraphPathWithGradient(props) {
  return createGraphPathBase({ ...props,
    shouldFillGradient: true
  });
}
//# sourceMappingURL=CreateGraphPath.js.map