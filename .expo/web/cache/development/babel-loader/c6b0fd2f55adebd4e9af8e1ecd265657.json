{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport Constants from 'expo-constants';\nimport { Platform } from 'expo-modules-core';\nimport { EventEmitter } from 'fbemitter';\nimport invariant from 'invariant';\nimport { v4 as uuidv4 } from 'uuid';\nimport getInstallationIdAsync from \"../environment/getInstallationIdAsync\";\nimport LogSerialization from \"./LogSerialization\";\n\nvar _sessionId = uuidv4();\n\nvar _logQueue = [];\n\nvar _transportEventEmitter = new EventEmitter();\n\nvar _logCounter = 0;\nvar _isSendingLogs = false;\nvar _completionPromise = null;\nvar _resolveCompletion2 = null;\n\nfunction enqueueRemoteLogAsync(level, additionalFields, data) {\n  var warning, lines, _await$LogSerializati, body, includesStack;\n\n  return _regeneratorRuntime.async(function enqueueRemoteLogAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!_isReactNativeWarning(data)) {\n            _context.next = 8;\n            break;\n          }\n\n          if (!(data.length === 0)) {\n            _context.next = 3;\n            break;\n          }\n\n          throw new Error(\"Warnings must include log arguments\");\n\n        case 3:\n          warning = data[0];\n\n          if (!(typeof warning !== 'string')) {\n            _context.next = 6;\n            break;\n          }\n\n          throw new TypeError(\"The log argument for a warning must be a string\");\n\n        case 6:\n          lines = warning.split('\\n');\n\n          if (lines.length > 1 && /^\\s+in /.test(lines[1])) {\n            data[0] = lines[0];\n          }\n\n        case 8:\n          _context.next = 10;\n          return _regeneratorRuntime.awrap(LogSerialization.serializeLogDataAsync(data, level));\n\n        case 10:\n          _await$LogSerializati = _context.sent;\n          body = _await$LogSerializati.body;\n          includesStack = _await$LogSerializati.includesStack;\n\n          _logQueue.push(_objectSpread({\n            count: _logCounter++,\n            level: level,\n            body: body,\n            includesStack: includesStack\n          }, additionalFields));\n\n          _sendRemoteLogsAsync().catch(function (error) {\n            setImmediate(function () {\n              throw error;\n            });\n          });\n\n        case 15:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _sendRemoteLogsAsync() {\n  var _Constants$manifest$l, _Constants$manifest, _Constants$manifest2, _Constants$manifest2$, _Constants$manifest2$2;\n\n  var batch, logUrl;\n  return _regeneratorRuntime.async(function _sendRemoteLogsAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!(_isSendingLogs || !_logQueue.length)) {\n            _context2.next = 2;\n            break;\n          }\n\n          return _context2.abrupt(\"return\");\n\n        case 2:\n          batch = _logQueue.splice(0);\n          logUrl = (_Constants$manifest$l = (_Constants$manifest = Constants.manifest) == null ? void 0 : _Constants$manifest.logUrl) != null ? _Constants$manifest$l : (_Constants$manifest2 = Constants.manifest2) == null ? void 0 : (_Constants$manifest2$ = _Constants$manifest2.extra) == null ? void 0 : (_Constants$manifest2$2 = _Constants$manifest2$.expoGo) == null ? void 0 : _Constants$manifest2$2.logUrl;\n\n          if (!(typeof logUrl !== 'string')) {\n            _context2.next = 6;\n            break;\n          }\n\n          throw new Error('The Expo project manifest must specify `logUrl`');\n\n        case 6:\n          _isSendingLogs = true;\n          _context2.prev = 7;\n          _context2.next = 10;\n          return _regeneratorRuntime.awrap(_sendNextLogBatchAsync(batch, logUrl));\n\n        case 10:\n          _context2.prev = 10;\n          _isSendingLogs = false;\n          return _context2.finish(10);\n\n        case 13:\n          if (!_logQueue.length) {\n            _context2.next = 17;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", _sendRemoteLogsAsync());\n\n        case 17:\n          if (_resolveCompletion2) {\n            _resolveCompletion2();\n          }\n\n        case 18:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, [[7,, 10, 13]], Promise);\n}\n\nfunction _sendNextLogBatchAsync(batch, logUrl) {\n  var response, headers, success;\n  return _regeneratorRuntime.async(function _sendNextLogBatchAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return _regeneratorRuntime.awrap(getInstallationIdAsync());\n\n        case 2:\n          _context3.t0 = _context3.sent;\n          _context3.t1 = _sessionId;\n          _context3.t2 = Platform.OS;\n          headers = {\n            'Content-Type': 'application/json',\n            Connection: 'keep-alive',\n            'Proxy-Connection': 'keep-alive',\n            Accept: 'application/json',\n            'Device-Id': _context3.t0,\n            'Session-Id': _context3.t1,\n            'Expo-Platform': _context3.t2\n          };\n\n          if (Constants.deviceName) {\n            headers['Device-Name'] = Constants.deviceName;\n          }\n\n          _context3.prev = 7;\n          _context3.next = 10;\n          return _regeneratorRuntime.awrap(fetch(logUrl, {\n            method: 'POST',\n            headers: headers,\n            body: JSON.stringify(batch)\n          }));\n\n        case 10:\n          response = _context3.sent;\n          _context3.next = 17;\n          break;\n\n        case 13:\n          _context3.prev = 13;\n          _context3.t3 = _context3[\"catch\"](7);\n\n          _transportEventEmitter.emit('error', {\n            error: _context3.t3\n          });\n\n          return _context3.abrupt(\"return\");\n\n        case 17:\n          success = response.status >= 200 && response.status < 300;\n\n          if (!success) {\n            _transportEventEmitter.emit('error', {\n              error: new Error(\"An HTTP error occurred when sending remote logs\"),\n              response: response\n            });\n          }\n\n        case 19:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[7, 13]], Promise);\n}\n\nfunction addTransportErrorListener(listener) {\n  return _transportEventEmitter.addListener('error', listener);\n}\n\nfunction _isReactNativeWarning(data) {\n  var message = data[0];\n  return data.length === 1 && typeof message === 'string' && message.startsWith('Warning: ');\n}\n\nexport default {\n  enqueueRemoteLogAsync: enqueueRemoteLogAsync,\n  addTransportErrorListener: addTransportErrorListener\n};\nexport function __waitForEmptyLogQueueAsync() {\n  if (_completionPromise) {\n    return _completionPromise;\n  }\n\n  if (!_isSendingLogs && !_logQueue.length) {\n    return Promise.resolve();\n  }\n\n  _completionPromise = new Promise(function (resolve) {\n    _resolveCompletion2 = function _resolveCompletion() {\n      invariant(!_isSendingLogs, \"Must not be sending logs at completion\");\n      invariant(!_logQueue.length, \"Log queue must be empty at completion\");\n      _completionPromise = null;\n      _resolveCompletion2 = null;\n      resolve();\n    };\n  });\n  return _completionPromise;\n}","map":{"version":3,"sources":["../../src/logs/RemoteLogging.ts"],"names":[],"mappings":"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","sourcesContent":["import Constants from 'expo-constants';\nimport { Platform } from 'expo-modules-core';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport invariant from 'invariant';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport getInstallationIdAsync from '../environment/getInstallationIdAsync';\nimport LogSerialization from './LogSerialization';\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\ntype LogEntry = {\n  count: number;\n  level: LogLevel;\n  body: LogData[];\n  includesStack: boolean;\n  groupDepth?: number;\n} & LogEntryFields;\n\nexport type LogEntryFields = {\n  shouldHide?: boolean;\n  groupDepth?: number;\n  groupCollapsed?: boolean;\n};\n\nexport type LogData = string | LogErrorData;\nexport type LogErrorData = { message: string; stack: string };\n\ntype TransportErrorListener = (event: { error: Error; response?: Response }) => void;\n\nconst _sessionId = uuidv4();\nconst _logQueue: LogEntry[] = [];\nconst _transportEventEmitter = new EventEmitter();\n\nlet _logCounter = 0;\nlet _isSendingLogs = false;\nlet _completionPromise: Promise<void> | null = null;\nlet _resolveCompletion: (() => void) | null = null;\n\nasync function enqueueRemoteLogAsync(\n  level: LogLevel,\n  additionalFields: LogEntryFields,\n  data: unknown[]\n): Promise<void> {\n  if (_isReactNativeWarning(data)) {\n    // Remove the stack trace from the warning message since we'll capture our own\n    if (data.length === 0) {\n      throw new Error(`Warnings must include log arguments`);\n    }\n    const warning = data[0];\n    if (typeof warning !== 'string') {\n      throw new TypeError(`The log argument for a warning must be a string`);\n    }\n    const lines = warning.split('\\n');\n    if (lines.length > 1 && /^\\s+in /.test(lines[1])) {\n      data[0] = lines[0];\n    }\n  }\n\n  const { body, includesStack } = await LogSerialization.serializeLogDataAsync(data, level);\n\n  _logQueue.push({\n    count: _logCounter++,\n    level,\n    body,\n    includesStack,\n    ...additionalFields,\n  });\n\n  // Send the logs asynchronously (system errors are emitted with transport error events) and throw an uncaught error\n  _sendRemoteLogsAsync().catch((error) => {\n    setImmediate(() => {\n      throw error;\n    });\n  });\n}\n\nasync function _sendRemoteLogsAsync(): Promise<void> {\n  if (_isSendingLogs || !_logQueue.length) {\n    return;\n  }\n\n  // Our current transport policy is to send all of the pending log messages in one batch. If we opt\n  // for another policy (ex: throttling) this is where to to implement it.\n  const batch = _logQueue.splice(0);\n\n  const logUrl = Constants.manifest?.logUrl ?? Constants.manifest2?.extra?.expoGo?.logUrl;\n  if (typeof logUrl !== 'string') {\n    throw new Error('The Expo project manifest must specify `logUrl`');\n  }\n\n  _isSendingLogs = true;\n  try {\n    await _sendNextLogBatchAsync(batch, logUrl);\n  } finally {\n    _isSendingLogs = false;\n  }\n\n  if (_logQueue.length) {\n    return _sendRemoteLogsAsync();\n  } else if (_resolveCompletion) {\n    _resolveCompletion();\n  }\n}\n\nasync function _sendNextLogBatchAsync(batch: LogEntry[], logUrl: string): Promise<void> {\n  let response;\n\n  const headers = {\n    'Content-Type': 'application/json',\n    Connection: 'keep-alive',\n    'Proxy-Connection': 'keep-alive',\n    Accept: 'application/json',\n    'Device-Id': await getInstallationIdAsync(),\n    'Session-Id': _sessionId,\n    'Expo-Platform': Platform.OS,\n  };\n  if (Constants.deviceName) {\n    headers['Device-Name'] = Constants.deviceName;\n  }\n  try {\n    response = await fetch(logUrl, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(batch),\n    });\n  } catch (error) {\n    _transportEventEmitter.emit('error', { error });\n    return;\n  }\n\n  const success = response.status >= 200 && response.status < 300;\n  if (!success) {\n    _transportEventEmitter.emit('error', {\n      error: new Error(`An HTTP error occurred when sending remote logs`),\n      response,\n    });\n  }\n}\n\nfunction addTransportErrorListener(listener: TransportErrorListener): EventSubscription {\n  return _transportEventEmitter.addListener('error', listener);\n}\n\nfunction _isReactNativeWarning(data: unknown[]): boolean {\n  // NOTE: RN does the same thing internally for YellowBox\n  const message = data[0];\n  return data.length === 1 && typeof message === 'string' && message.startsWith('Warning: ');\n}\n\nexport default {\n  enqueueRemoteLogAsync,\n  addTransportErrorListener,\n};\n\n/**\n * Returns a promise that resolves when all entries in the log queue have been sent. This method is\n * intended for testing only.\n */\nexport function __waitForEmptyLogQueueAsync(): Promise<void> {\n  if (_completionPromise) {\n    return _completionPromise;\n  }\n\n  if (!_isSendingLogs && !_logQueue.length) {\n    return Promise.resolve();\n  }\n\n  _completionPromise = new Promise((resolve) => {\n    _resolveCompletion = () => {\n      invariant(!_isSendingLogs, `Must not be sending logs at completion`);\n      invariant(!_logQueue.length, `Log queue must be empty at completion`);\n\n      _completionPromise = null;\n      _resolveCompletion = null;\n\n      resolve();\n    };\n  });\n  return _completionPromise;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}