{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport Constants from 'expo-constants';\nimport prettyFormat from 'pretty-format';\nimport parseErrorStack from 'react-native/Libraries/Core/Devtools/parseErrorStack';\nimport symbolicateStackTrace from 'react-native/Libraries/Core/Devtools/symbolicateStackTrace';\nimport ReactNodeFormatter from \"./format/ReactNodeFormatter\";\nexport var EXPO_CONSOLE_METHOD_NAME = '__expoConsoleLog';\n\nfunction serializeLogDataAsync(data, level) {\n  var serializedValues, includesStack, rawStack, syntheticError, stack, errorMessage, serializedError, error, _errorMessage, _serializedError;\n\n  return _regeneratorRuntime.async(function serializeLogDataAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          includesStack = false;\n\n          if (!_stackTraceLogsSupported()) {\n            _context.next = 32;\n            break;\n          }\n\n          if (!_isUnhandledPromiseRejection(data, level)) {\n            _context.next = 11;\n            break;\n          }\n\n          rawStack = data[0];\n          syntheticError = {\n            stack: rawStack\n          };\n          _context.next = 7;\n          return _regeneratorRuntime.awrap(_symbolicateErrorAsync(syntheticError));\n\n        case 7:\n          stack = _context.sent;\n\n          if (!stack.length) {\n            serializedValues = _stringifyLogData(data);\n          } else {\n            errorMessage = rawStack.split('\\n')[1];\n            serializedValues = [{\n              message: \"[Unhandled promise rejection: \" + errorMessage + \"]\",\n              stack: _formatStack(stack)\n            }];\n            includesStack = true;\n          }\n\n          _context.next = 30;\n          break;\n\n        case 11:\n          if (!(data.length === 1 && data[0] instanceof Error)) {\n            _context.next = 19;\n            break;\n          }\n\n          _context.next = 14;\n          return _regeneratorRuntime.awrap(_serializeErrorAsync(data[0]));\n\n        case 14:\n          serializedError = _context.sent;\n          serializedValues = [serializedError];\n          includesStack = serializedError.hasOwnProperty('stack');\n          _context.next = 30;\n          break;\n\n        case 19:\n          if (!(level === 'warn' || level === 'error')) {\n            _context.next = 29;\n            break;\n          }\n\n          error = _captureConsoleStackTrace();\n          _errorMessage = _stringifyLogData(data).join(', ');\n          _context.next = 24;\n          return _regeneratorRuntime.awrap(_serializeErrorAsync(error, _errorMessage));\n\n        case 24:\n          _serializedError = _context.sent;\n          serializedValues = [_serializedError];\n          includesStack = _serializedError.hasOwnProperty('stack');\n          _context.next = 30;\n          break;\n\n        case 29:\n          serializedValues = _stringifyLogData(data);\n\n        case 30:\n          _context.next = 33;\n          break;\n\n        case 32:\n          serializedValues = _stringifyLogData(data);\n\n        case 33:\n          return _context.abrupt(\"return\", {\n            body: _toConsumableArray(serializedValues),\n            includesStack: includesStack\n          });\n\n        case 34:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _stringifyLogData(data) {\n  return data.map(function (item) {\n    var LOG_MESSAGE_MAX_LENGTH = 10000;\n    var result = typeof item === 'string' ? item : prettyFormat(item, {\n      plugins: [ReactNodeFormatter]\n    });\n\n    if (result.length > LOG_MESSAGE_MAX_LENGTH) {\n      var truncatedResult = result.substring(0, LOG_MESSAGE_MAX_LENGTH);\n      truncatedResult += \"...(truncated to the first \" + LOG_MESSAGE_MAX_LENGTH + \" characters)\";\n      return truncatedResult;\n    } else {\n      return result;\n    }\n  });\n}\n\nfunction _serializeErrorAsync(error, message) {\n  var stack, formattedStack;\n  return _regeneratorRuntime.async(function _serializeErrorAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (message == null) {\n            message = error.message;\n          }\n\n          if (!(!error.stack || !error.stack.length)) {\n            _context2.next = 3;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", prettyFormat(error));\n\n        case 3:\n          _context2.next = 5;\n          return _regeneratorRuntime.awrap(_symbolicateErrorAsync(error));\n\n        case 5:\n          stack = _context2.sent;\n          formattedStack = _formatStack(stack);\n          return _context2.abrupt(\"return\", {\n            message: message,\n            stack: formattedStack\n          });\n\n        case 8:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _symbolicateErrorAsync(error) {\n  var parsedStack, symbolicatedStack, _await$symbolicateSta, _await$symbolicateSta2;\n\n  return _regeneratorRuntime.async(function _symbolicateErrorAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          parsedStack = parseErrorStack(error == null ? void 0 : error.stack);\n          _context3.prev = 1;\n          _context3.next = 4;\n          return _regeneratorRuntime.awrap(symbolicateStackTrace(parsedStack));\n\n        case 4:\n          _context3.t0 = _await$symbolicateSta2 = _context3.sent;\n\n          if (!(_context3.t0 == null)) {\n            _context3.next = 9;\n            break;\n          }\n\n          _context3.t1 = void 0;\n          _context3.next = 10;\n          break;\n\n        case 9:\n          _context3.t1 = _await$symbolicateSta2.stack;\n\n        case 10:\n          _context3.t2 = _await$symbolicateSta = _context3.t1;\n\n          if (!(_context3.t2 != null)) {\n            _context3.next = 15;\n            break;\n          }\n\n          _context3.t3 = _await$symbolicateSta;\n          _context3.next = 16;\n          break;\n\n        case 15:\n          _context3.t3 = null;\n\n        case 16:\n          symbolicatedStack = _context3.t3;\n          _context3.next = 22;\n          break;\n\n        case 19:\n          _context3.prev = 19;\n          _context3.t4 = _context3[\"catch\"](1);\n          return _context3.abrupt(\"return\", parsedStack);\n\n        case 22:\n          if (symbolicatedStack) {\n            _context3.next = 24;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", parsedStack);\n\n        case 24:\n          return _context3.abrupt(\"return\", symbolicatedStack.map(_removeProjectRoot));\n\n        case 25:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[1, 19]], Promise);\n}\n\nfunction _formatStack(stack) {\n  return stack.map(function (frame) {\n    var line = frame.file + \":\" + frame.lineNumber;\n\n    if (frame.column != null) {\n      line += \":\" + frame.column;\n    }\n\n    line += \" in \" + frame.methodName;\n    return line;\n  }).join('\\n');\n}\n\nfunction _removeProjectRoot(frame) {\n  var filename = frame.file;\n\n  if (filename == null) {\n    return frame;\n  }\n\n  var projectRoot = _getProjectRoot();\n\n  if (projectRoot == null) {\n    return frame;\n  }\n\n  if (filename.startsWith(projectRoot)) {\n    filename = filename.substring(projectRoot.length);\n\n    if (filename[0] === '/' || filename[0] === '\\\\') {\n      filename = filename.substring(1);\n    }\n\n    frame.file = filename;\n  }\n\n  return frame;\n}\n\nfunction _stackTraceLogsSupported() {\n  return !!(__DEV__ && _getProjectRoot());\n}\n\nfunction _isUnhandledPromiseRejection(data, level) {\n  return level === 'warn' && typeof data[0] === 'string' && /^Possible Unhandled Promise Rejection/.test(data[0]);\n}\n\nfunction _captureConsoleStackTrace() {\n  try {\n    throw new Error();\n  } catch (error) {\n    var stackLines = error.stack.split('\\n');\n    var consoleMethodIndex = stackLines.findIndex(function (frame) {\n      return frame.includes(EXPO_CONSOLE_METHOD_NAME);\n    });\n\n    if (consoleMethodIndex !== -1) {\n      stackLines = stackLines.slice(consoleMethodIndex + 1);\n      error.stack = stackLines.join('\\n');\n    }\n\n    return error;\n  }\n}\n\nfunction _getProjectRoot() {\n  var _ref, _Constants$manifest$d, _Constants$manifest, _Constants$manifest$d2, _Constants$manifest2, _Constants$manifest2$, _Constants$manifest2$2, _Constants$manifest2$3;\n\n  return (_ref = (_Constants$manifest$d = (_Constants$manifest = Constants.manifest) == null ? void 0 : (_Constants$manifest$d2 = _Constants$manifest.developer) == null ? void 0 : _Constants$manifest$d2.projectRoot) != null ? _Constants$manifest$d : (_Constants$manifest2 = Constants.manifest2) == null ? void 0 : (_Constants$manifest2$ = _Constants$manifest2.extra) == null ? void 0 : (_Constants$manifest2$2 = _Constants$manifest2$.expoGo) == null ? void 0 : (_Constants$manifest2$3 = _Constants$manifest2$2.developer) == null ? void 0 : _Constants$manifest2$3.projectRoot) != null ? _ref : null;\n}\n\nexport default {\n  serializeLogDataAsync: serializeLogDataAsync\n};","map":{"version":3,"sources":["../../src/logs/LogSerialization.ts"],"names":[],"mappings":"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","sourcesContent":["import Constants from 'expo-constants';\nimport prettyFormat from 'pretty-format';\nimport parseErrorStack, { StackFrame } from 'react-native/Libraries/Core/Devtools/parseErrorStack';\nimport symbolicateStackTrace from 'react-native/Libraries/Core/Devtools/symbolicateStackTrace';\n\nimport { LogData, LogLevel } from './RemoteLogging';\nimport ReactNodeFormatter from './format/ReactNodeFormatter';\n\ntype SerializedData = {\n  body: LogData[];\n  includesStack: boolean;\n};\n\nexport const EXPO_CONSOLE_METHOD_NAME = '__expoConsoleLog';\n\nasync function serializeLogDataAsync(data: unknown[], level: LogLevel): Promise<SerializedData> {\n  let serializedValues: readonly LogData[];\n  let includesStack = false;\n\n  if (_stackTraceLogsSupported()) {\n    if (_isUnhandledPromiseRejection(data, level)) {\n      const rawStack = data[0] as string;\n      const syntheticError = { stack: rawStack };\n      const stack = await _symbolicateErrorAsync(syntheticError as Error);\n\n      if (!stack.length) {\n        serializedValues = _stringifyLogData(data);\n      } else {\n        // NOTE: This doesn't handle error messages with newlines\n        const errorMessage = rawStack.split('\\n')[1];\n        serializedValues = [\n          {\n            message: `[Unhandled promise rejection: ${errorMessage}]`,\n            stack: _formatStack(stack),\n          },\n        ];\n        includesStack = true;\n      }\n    } else if (data.length === 1 && data[0] instanceof Error) {\n      // When there's only one argument to the log function and that argument is an error, we\n      // include the error's stack. If there's more than one argument then we don't include the\n      // stack because it's not easy to display nicely in our current UI.\n\n      const serializedError = await _serializeErrorAsync(data[0] as Error);\n      serializedValues = [serializedError];\n      includesStack = serializedError.hasOwnProperty('stack');\n    } else if (level === 'warn' || level === 'error') {\n      // For console.warn and console.error it is usually useful to know the stack that leads to the\n      // warning or error, so we provide this information to help out with debugging\n\n      const error = _captureConsoleStackTrace();\n      // [\"hello\", \"world\"] becomes \"hello, world\"\n      const errorMessage = _stringifyLogData(data).join(', ');\n\n      const serializedError = await _serializeErrorAsync(error, errorMessage);\n      serializedValues = [serializedError];\n      includesStack = serializedError.hasOwnProperty('stack');\n    } else {\n      serializedValues = _stringifyLogData(data);\n    }\n  } else {\n    serializedValues = _stringifyLogData(data);\n  }\n\n  return {\n    body: [...serializedValues],\n    includesStack,\n  };\n}\n\nfunction _stringifyLogData(data: unknown[]): string[] {\n  return data.map((item) => {\n    // define the max length for log msg to be first 10000 characters\n    const LOG_MESSAGE_MAX_LENGTH = 10000;\n    const result =\n      typeof item === 'string' ? item : prettyFormat(item, { plugins: [ReactNodeFormatter] });\n    // check the size of string returned\n    if (result.length > LOG_MESSAGE_MAX_LENGTH) {\n      let truncatedResult = result.substring(0, LOG_MESSAGE_MAX_LENGTH);\n      // truncate the result string to the max length\n      truncatedResult += `...(truncated to the first ${LOG_MESSAGE_MAX_LENGTH} characters)`;\n      return truncatedResult;\n    } else {\n      return result;\n    }\n  });\n}\n\nasync function _serializeErrorAsync(error: Error, message?: string): Promise<LogData> {\n  if (message == null) {\n    message = error.message;\n  }\n\n  if (!error.stack || !error.stack.length) {\n    return prettyFormat(error);\n  }\n\n  const stack = await _symbolicateErrorAsync(error);\n  const formattedStack = _formatStack(stack);\n\n  return { message, stack: formattedStack };\n}\n\nasync function _symbolicateErrorAsync(error: Error): Promise<StackFrame[]> {\n  // @ts-ignore: parseErrorStack accepts nullable string after RN 0.64 but @types/react-native does not updated yet.\n  const parsedStack = parseErrorStack(error?.stack);\n  let symbolicatedStack: StackFrame[] | null;\n  try {\n    // @ts-ignore: symbolicateStackTrace has different real/Flow declaration\n    // than the one in DefinitelyTyped.\n    symbolicatedStack = (await symbolicateStackTrace(parsedStack))?.stack ?? null;\n  } catch {\n    return parsedStack;\n  }\n\n  // In this context an unsymbolicated stack is better than no stack\n  if (!symbolicatedStack) {\n    return parsedStack;\n  }\n\n  // Clean the stack trace\n  return symbolicatedStack.map(_removeProjectRoot);\n}\n\nfunction _formatStack(stack: StackFrame[]): string {\n  return stack\n    .map((frame) => {\n      let line = `${frame.file}:${frame.lineNumber}`;\n      if (frame.column != null) {\n        line += `:${frame.column}`;\n      }\n      line += ` in ${frame.methodName}`;\n      return line;\n    })\n    .join('\\n');\n}\n\nfunction _removeProjectRoot(frame: StackFrame): StackFrame {\n  let filename = frame.file;\n  if (filename == null) {\n    return frame;\n  }\n\n  const projectRoot = _getProjectRoot();\n  if (projectRoot == null) {\n    return frame;\n  }\n\n  if (filename.startsWith(projectRoot)) {\n    filename = filename.substring(projectRoot.length);\n    if (filename[0] === '/' || filename[0] === '\\\\') {\n      filename = filename.substring(1);\n    }\n    frame.file = filename;\n  }\n\n  return frame;\n}\n\n/**\n * Returns whether the development server that served this project supports logs with a stack trace.\n * Specifically, the version of Expo CLI that includes `projectRoot` in the manifest also accepts\n * payloads of the form:\n *\n * {\n *   includesStack: boolean, body: [{ message: string, stack: string }],\n * }\n */\nfunction _stackTraceLogsSupported(): boolean {\n  return !!(__DEV__ && _getProjectRoot());\n}\n\nfunction _isUnhandledPromiseRejection(data: unknown[], level: LogLevel): boolean {\n  return (\n    level === 'warn' &&\n    typeof data[0] === 'string' &&\n    /^Possible Unhandled Promise Rejection/.test(data[0] as string)\n  );\n}\n\nfunction _captureConsoleStackTrace(): Error {\n  try {\n    throw new Error();\n  } catch (error) {\n    let stackLines = error.stack.split('\\n');\n    const consoleMethodIndex = stackLines.findIndex((frame) =>\n      frame.includes(EXPO_CONSOLE_METHOD_NAME)\n    );\n    if (consoleMethodIndex !== -1) {\n      stackLines = stackLines.slice(consoleMethodIndex + 1);\n      error.stack = stackLines.join('\\n');\n    }\n    return error;\n  }\n}\n\nfunction _getProjectRoot(): string | null {\n  return (\n    Constants.manifest?.developer?.projectRoot ??\n    Constants.manifest2?.extra?.expoGo?.developer?.projectRoot ??\n    null\n  );\n}\n\nexport default {\n  serializeLogDataAsync,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}